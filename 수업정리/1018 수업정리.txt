push_back()
공백 벡터에서 시작하여서 요소가 하나씩 추가될 때마다 벡터의 크기를 확대하는 멤버 함수.

pop_back()
벡터의 끝에서 요소를 제거하고 벡터의 크기를 하나 감소시키는 멤버함수.
주의할 점은 pop_back은 요소를 반환하지 않기 때문에 삭제하기 전에 미리 삭제할 요소를 다른곳에 저장하여야 한다.

벡터에서 요소의 위치
벡터에서 요소의 위치는 반복자를 이용하여 표시한다. begin()과 end()는 반복자로써 벡터의시작과 끝을 식별한다.
*begin으로 식별되는 요소는 시퀀스의 일부이지만 end는 시퀀스의 끝을 하나 넘는 요소(NULL)를 가리킨다.*중요함

반복자를 사용하여 벡터 안의 모든 요소를 출력하는 문장은 다음과 같다.
반복자로부터 요소의 값을 얻으려면 *p하면 된다. 반복자가 중요한 것은 벡터 안의 요소들을 가리킬 수 있기 때문이다. stl 알고리즘을 적용할 때에는 반복자를 사용하여야 한다.
for (auto p = v.begin(); p != v.end(); ++p) //여기서 auto는 포인터형 변수타입을 가진다. v.begin()이 포인터이기 때문이다.
    cout << *p << endl;

벡터는 동적 배열이기 때문에 배열의 중간에서 요소를 삭제할 수도 있다. 
인덱스가 i라고 하면 다음과 같은 문장으로 i번째 요소를 삭제할 수 있다.
v.erase(v.begin()+i);

벡터에는 편리성을 위하여 연산자들이 중복 정의(연산자 오버로딩)되어 있다. 대입 연산자인 = 연산자를 이용하면 하나의 벡터를 다른벡터로 복사할 수 있다.
기존의 배열에서는 하나의 배열을 다른 배열로 대입 연산자를 이용하여서 복사할 수 없지만 벡터에서는 = 연산자를 이용하여 벡터끼리 복사할 수 있다.
벡터와 벡터를 비교할 때에도 == 또는 != 연산자를 사용할 수 있다. == 연산자는 벡터의 요소의 개수와 값이 모두 일치할 때만 true를 반환한다.

벡터와 알고리즘
벡터를 사용하는 이유중의 하나는 편리한 STL 알고리즘을 사용할 수 있기 때문이다.

객체를 생성할때 초기값을 주지 않아도 디폴트 인수를 선언하면 오류가 발생하지 않는다.
접근자, 설정자 시험에 나옴